<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <style>
        :root {
            --bg-main: #FFFBFE;
            --bg-container: #FFFFFF;
            --border-color: #D0CFCF;
            --text-dark: #565254;
            --text-medium: #7A7D7D;
            --text-light: #FFFFFF;
        }
        body {
            font-family: 'Poppins', sans-serif;
            background-color: var(--bg-main);
            color: var(--text-dark); 
        }
        .main-container {
             background-color: var(--bg-container);
             border: 1px solid var(--border-color);
        }
        .loader {
            border: 5px solid var(--border-color);
            border-top: 5px solid var(--text-dark);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        .loader-small {
            border: 2px solid var(--border-color);
            border-top: 2px solid var(--text-dark);
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
            display: inline-block;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .custom-file-upload {
            border: 2px dashed var(--border-color);
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
        }
        .custom-file-upload:hover {
            background-color: var(--bg-main);
            border-color: var(--text-medium);
        }
        .answer-option {
            background-color: var(--bg-main);
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        .answer-option:hover:not(.disabled) {
            border-color: var(--text-medium);
            transform: translateY(-2px);
        }
        .answer-option.correct {
            border-color: #3fb950;
            background-color: rgba(46, 160, 67, 0.1);
        }
        .answer-option.incorrect {
            border-color: #f85149;
            background-color: rgba(248, 81, 73, 0.1);
        }
        .answer-option.disabled {
            cursor: not-allowed;
            opacity: 0.7;
        }
        .explanation {
            color: var(--text-medium); 
        }
        .explanation p {
            display: inline;
            margin: 0;
        }
        .form-element {
            background-color: var(--bg-main);
            border: 1px solid var(--border-color);
            color: var(--text-dark);
        }
        .form-element:focus {
            border-color: var(--text-dark);
            outline: none;
            box-shadow: 0 0 0 3px rgba(86, 82, 84, 0.3);
        }
        .primary-btn {
            background-color: var(--text-dark);
            color: var(--text-light);
            border: 1px solid var(--text-dark);
        }
        .primary-btn:hover:not(:disabled) {
             filter: brightness(1.2);
        }
        .nav-btn {
            background-color: var(--bg-container);
            border: 1px solid var(--border-color);
            color: var(--text-dark);
        }
        .nav-btn:hover:not(:disabled) {
            border-color: var(--text-dark);
            background-color: var(--bg-main);
        }
        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body class="text-gray-800">

    <div class="container mx-auto max-w-4xl px-4 py-8 sm:py-12">
        <header class="text-center mb-10 sm:mb-12">
            <h1 class="text-3xl sm:text-4xl md:text-5xl font-bold text-gray-800">Quiz Generator</h1>
        </header>

        <main>
            <div id="config-section" class="main-container p-4 sm:p-6 md:p-8 rounded-xl shadow-lg transition-all">
                <div class="space-y-8">
                    <div>
                        <h2 class="text-xl font-semibold mb-4 text-gray-800">1. Upload Your Content</h2>
                        <label for="file-upload" class="custom-file-upload w-full text-center block p-6 rounded-lg">
                            <svg class="w-10 h-10 sm:w-12 sm:h-12 mx-auto text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path></svg>
                            <span class="mt-2 block text-sm font-medium text-gray-500">Click to upload PDFs</span>
                            <span class="mt-1 block text-xs text-gray-400">Multiple files supported</span>
                        </label>
                        <input id="file-upload" type="file" class="hidden" accept=".pdf" multiple>
                        <div id="uploaded-files-list" class="mt-4 space-y-2 max-h-48 overflow-y-auto"></div>
                    </div>

                    <div>
                        <h2 class="text-xl font-semibold mb-4 text-gray-800">2. Customize Your Quiz</h2>
                        <div class="grid grid-cols-1">
                             <div>
                                <label for="question-style" class="block text-sm font-medium text-gray-500 mb-2">Question Style</label>
                                <select id="question-style" class="w-full p-3 form-element rounded-lg transition">
                                    <option value="standard">Standard</option>
                                    <option value="vignette">Vignette</option>
                                </select>
                            </div>
                        </div>
                        <div class="mt-6">
                             <label for="custom-prompt" class="block text-sm font-medium text-gray-500 mb-2">Customize the Prompt (Optional)</label>
                             <textarea id="custom-prompt" rows="3" class="w-full p-3 form-element rounded-lg transition" placeholder="Add additional details or instructions here..."></textarea>
                        </div>
                    </div>
                </div>

                <div class="mt-10 text-center">
                    <button id="generate-quiz-btn" class="primary-btn w-full sm:w-auto font-bold py-3 px-8 rounded-lg hover:shadow-lg focus:outline-none focus:ring-4 focus:ring-gray-400/50 transition-all transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:scale-100">
                        Generate Quiz
                    </button>
                </div>
            </div>
            
            <div id="loader-section" class="hidden text-center p-8">
                <div class="loader"></div>
                <p class="text-lg text-gray-500">Generating your quiz...</p>
            </div>

            <div id="quiz-section" class="hidden mt-10 main-container p-4 sm:p-6 md:p-8 rounded-xl shadow-lg">
                <p id="quiz-progress" class="text-sm text-gray-500 text-right mb-4"></p>
                <div id="quiz-content">
                     </div>
                <div class="flex flex-col sm:flex-row justify-between mt-8 space-y-3 sm:space-y-0 sm:space-x-4">
                     <button id="previous-question-btn" class="nav-btn w-full sm:w-auto font-bold py-3 px-6 md:px-8 rounded-lg transition-all">Previous</button>
                     <button id="next-question-btn" class="nav-btn w-full sm:w-auto font-bold py-3 px-6 md:px-8 rounded-lg transition-all">Next</button>
                </div>
            </div>

            <div id="results-section" class="hidden mt-10 main-container p-4 sm:p-6 md:p-8 rounded-xl shadow-lg">
                <h2 class="text-2xl md:text-3xl font-bold mb-2 text-center text-gray-800">Quiz Complete!</h2>
                <p id="score" class="text-lg md:text-xl font-bold text-center mb-6 text-gray-700"></p>
                
                <div id="review-section" class="hidden mt-6 text-left">
                    <h3 class="text-lg md:text-xl font-semibold mb-4 text-gray-800">Review Incorrect Answers:</h3>
                    <div id="review-content" class="space-y-4 max-h-64 overflow-y-auto pr-2"></div>
                </div>

                <div class="flex flex-col sm:flex-row justify-center mt-8 space-y-3 sm:space-y-0 sm:space-x-4">
                    <button id="new-quiz-btn" class="primary-btn w-full sm:w-auto font-bold py-3 px-8 rounded-lg transition-all">New Quiz (Same Content)</button>
                    <button id="start-over-btn" class="bg-gray-200 w-full sm:w-auto text-gray-800 font-bold py-3 px-8 rounded-lg hover:bg-gray-300 focus:outline-none focus:ring-4 focus:ring-gray-400/50 transition-all">Start Over</button>
                </div>
            </div>

            <div id="error-message" class="hidden mt-6 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative" role="alert">
                <strong class="font-bold">Error:</strong>
                <span class="block sm:inline" id="error-text"></span>
            </div>
        </main>
    </div>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

        // DOM Elements
        const fileUpload = document.getElementById('file-upload');
        const uploadedFilesList = document.getElementById('uploaded-files-list');
        const generateQuizBtn = document.getElementById('generate-quiz-btn');
        const configSection = document.getElementById('config-section');
        const loaderSection = document.getElementById('loader-section');
        const quizSection = document.getElementById('quiz-section');
        const quizProgress = document.getElementById('quiz-progress');
        const quizContent = document.getElementById('quiz-content');
        const previousQuestionBtn = document.getElementById('previous-question-btn');
        const nextQuestionBtn = document.getElementById('next-question-btn');
        const resultsSection = document.getElementById('results-section');
        const scoreDisplay = document.getElementById('score');
        const reviewSection = document.getElementById('review-section');
        const reviewContent = document.getElementById('review-content');
        const startOverBtn = document.getElementById('start-over-btn');
        const newQuizBtn = document.getElementById('new-quiz-btn');
        const errorMessage = document.getElementById('error-message');
        const errorText = document.getElementById('error-text');

        // State
        let uploadedFiles = [];
        let firstQuizData = [];
        let quizData = [];
        let currentQuestionIndex = 0;
        let userAnswers = [];

        // Event Listeners
        fileUpload.addEventListener('change', async (e) => {
            const files = e.target.files;
            if (!files.length) return;
            
            generateQuizBtn.disabled = true;
            hideError();

            for (const file of files) {
                if (uploadedFiles.some(f => f.name === file.name)) continue;

                const fileIndex = uploadedFiles.length;
                renderUploadedFile(file.name, 'processing', fileIndex);

                try {
                    const reader = new FileReader();
                    const textContent = await new Promise((resolve, reject) => {
                        reader.onload = async (event) => {
                            try {
                                const pdfData = new Uint8Array(event.target.result);
                                const pdf = await pdfjsLib.getDocument({ data: pdfData }).promise;
                                let fullText = '';
                                for (let i = 1; i <= pdf.numPages; i++) {
                                    const page = await pdf.getPage(i);
                                    const pageContent = await page.getTextContent();
                                    fullText += pageContent.items.map(item => item.str).join(' ');
                                }
                                resolve(fullText);
                            } catch (pdfError) {
                                reject(pdfError);
                            }
                        };
                        reader.onerror = (error) => reject(error);
                        reader.readAsArrayBuffer(file);
                    });
                    
                    uploadedFiles.push({ name: file.name, content: textContent });
                    updateUploadedFileStatus(fileIndex, file.name, 'loaded');

                } catch (error) {
                    console.error(`Failed to process ${file.name}:`, error);
                    updateUploadedFileStatus(fileIndex, file.name, 'error');
                }
            }
            generateQuizBtn.disabled = uploadedFiles.length === 0;
        });
        
        uploadedFilesList.addEventListener('click', (e) => {
            if (e.target.classList.contains('remove-file-btn')) {
                const fileName = e.target.dataset.name;
                uploadedFiles = uploadedFiles.filter(f => f.name !== fileName);
                renderAllUploadedFiles();
                generateQuizBtn.disabled = uploadedFiles.length === 0;
            }
        });

        generateQuizBtn.addEventListener('click', () => {
             const basePrompt = `Generate a 20 question multiple choice quiz based on the lecture content. The questions should be challenging, providing the least amount of information possible in the question to make it harder. The answer choices should not be obvious (e.g. the correct one is the longest one). The questions should test my deep understanding of the concepts.`;
             initiateQuizGeneration(basePrompt);
        });
        
        newQuizBtn.addEventListener('click', () => {
            const incorrectQuestions = [];
            userAnswers.forEach((answerIndex, questionIndex) => {
                if (answerIndex !== null) {
                    const question = firstQuizData[questionIndex];
                    const selectedOption = question.options[answerIndex];
                    if (!selectedOption.is_correct) {
                        incorrectQuestions.push(question);
                    }
                }
            });

            const previousQuestionsText = firstQuizData.map(q => q.question).join('\n');
            const incorrectQuestionsText = incorrectQuestions.map(q => {
                 const correctAnswer = q.options.find(opt => opt.is_correct).option_text;
                 return `Question: ${q.question}\nCorrect Answer: ${correctAnswer}`;
            }).join('\n\n');
            
            const newQuizPrompt = `You are generating a follow-up quiz. The user has already taken one quiz based on the provided content.

            The following questions were on the FIRST quiz:
            ${previousQuestionsText}

            The user answered these questions INCORRECTLY:
            ${incorrectQuestionsText}

            Your task is to generate a NEW 20-question multiple choice quiz. This new quiz should prioritize:
            1. Testing the user on the concepts they got wrong in the first quiz, but with NEW questions.
            2. Covering new concepts from the provided content that were NOT included in the first quiz.`;
            
            initiateQuizGeneration(newQuizPrompt);
        });

        async function initiateQuizGeneration(basePrompt) {
            if (uploadedFiles.length === 0) {
                showError('Please upload at least one PDF file.');
                return;
            }
            hideError();
            configSection.classList.add('hidden');
            resultsSection.classList.add('hidden');
            loaderSection.classList.remove('hidden');

            const questionStyle = document.getElementById('question-style').value;
            const customPrompt = document.getElementById('custom-prompt').value;
            let combinedContent = uploadedFiles.map(f => `--- START OF ${f.name} ---\n\n${f.content}\n\n--- END OF ${f.name} ---`).join('\n\n');
            
            const MAX_CONTENT_LENGTH = 150000;
            if (combinedContent.length > MAX_CONTENT_LENGTH) {
                console.warn(`Content length (${combinedContent.length}) exceeds the maximum of ${MAX_CONTENT_LENGTH}. Truncating content.`);
                combinedContent = combinedContent.substring(0, MAX_CONTENT_LENGTH);
            }

            const finalPrompt = `${basePrompt} The questions should be ${questionStyle}. ${customPrompt}`;

            try {
                const result = await generateQuiz(combinedContent, finalPrompt);

                quizData = result;
                if (!quizData || quizData.length === 0) {
                    throw new Error("AI failed to generate questions. Please try a different file or prompt.");
                }
                
                quizData.forEach(q => shuffle(q.options));

                if (firstQuizData.length === 0) {
                    firstQuizData = JSON.parse(JSON.stringify(quizData));
                }

                currentQuestionIndex = 0;
                userAnswers = new Array(quizData.length).fill(null);
                loaderSection.classList.add('hidden');
                quizSection.classList.remove('hidden');
                showQuestion();
            } catch (error) {
                handleError(error);
            }
        }


        nextQuestionBtn.addEventListener('click', () => {
            if (currentQuestionIndex < quizData.length - 1) {
                currentQuestionIndex++;
                showQuestion();
            } else {
                showFinalResults();
            }
        });

        previousQuestionBtn.addEventListener('click', () => {
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                showQuestion();
            }
        });
        
        quizContent.addEventListener('click', (e) => {
            const selectedOption = e.target.closest('.answer-option');
            if (selectedOption && !selectedOption.classList.contains('disabled')) {
                handleAnswerSelection(selectedOption);
            }
        });

        startOverBtn.addEventListener('click', resetUIForStartOver);

        // UI Rendering Functions
        function renderUploadedFile(name, status, index) {
            const fileEl = document.createElement('div');
            fileEl.id = `file-item-${index}`;
            fileEl.className = 'flex items-center justify-between bg-gray-100 p-2 rounded';
            
            let statusIndicator = '';
            if (status === 'processing') {
                statusIndicator = `<div class="loader-small"></div>`;
            } else if (status === 'error') {
                statusIndicator = `<span class="text-red-500 text-xs">Failed</span>`;
            }

            fileEl.innerHTML = `
                <span class="text-sm text-gray-700 truncate pr-2">${name}</span>
                <div class="flex items-center space-x-2">
                    <div class="file-status">${statusIndicator}</div>
                    <button data-name="${name}" class="remove-file-btn text-red-500 hover:text-red-400">&times;</button>
                </div>
            `;
            uploadedFilesList.appendChild(fileEl);
        }

        function updateUploadedFileStatus(index, name, status) {
            const fileEl = document.getElementById(`file-item-${index}`);
            if (!fileEl) return;
            const statusDiv = fileEl.querySelector('.file-status');
            if (status === 'loaded') {
                statusDiv.innerHTML = `<span class="text-green-500 text-xs">Ready</span>`;
            } else if (status === 'error') {
                statusDiv.innerHTML = `<span class="text-red-500 text-xs">Failed</span>`;
            }
        }
        
        function renderAllUploadedFiles() {
            uploadedFilesList.innerHTML = '';
            uploadedFiles.forEach((file, index) => {
                renderUploadedFile(file.name, 'loaded', index);
            });
        }

        // Gemini API Calls
         // Gemini API Calls
        async function callGeminiAPI(prompt, schema = null) {
            const payload = {
                contents: [{ role: "user", parts: [{ text: prompt }] }],
            };
            if (schema) {
                payload.generationConfig = {
                    responseMimeType: "application/json",
                    responseSchema: schema,
                };
            }
            
            // This is the only part that changes:
            // We now call our own secure function instead of the Google API directly.
            const apiUrl = `/api/generate`;

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.text();
                console.error("API Error Response:", errorBody);
                throw new Error(`API request failed with status ${response.status}`);
            }

            // The rest of the logic remains the same, as our function returns the same format.
            const result = await response.json();
            if (result.candidates && result.candidates[0]?.content?.parts[0]?.text) {
                return result.candidates[0].content.parts[0].text;
            } else {
                console.error("Unexpected API response structure:", result);
                throw new Error("Received an unexpected response from the AI.");
            }
        }

        
        async function generateQuiz(content, promptText) {
            const fullPrompt = `${promptText}
            Content: --- ${content} ---
            Provide the output as a valid JSON array of objects.`;
            
            const quizSchema = {
                type: "ARRAY",
                items: {
                    type: "OBJECT",
                    properties: {
                        question: { type: "STRING" },
                        options: {
                            type: "ARRAY",
                            items: {
                                type: "OBJECT",
                                properties: {
                                    option_text: { type: "STRING" },
                                    is_correct: { type: "BOOLEAN" },
                                    explanation: { type: "STRING", description: "A concise, one-sentence explanation for why this specific option is correct or incorrect. Do not include conversational filler." },
                                },
                                required: ["option_text", "is_correct", "explanation"],
                            },
                        },
                    },
                    required: ["question", "options"],
                },
            };

            const jsonString = await callGeminiAPI(fullPrompt, quizSchema);
            try {
                return JSON.parse(jsonString);
            } catch (e) {
                console.error("Failed to parse JSON from API response:", jsonString);
                throw new Error("Could not parse the quiz data from the AI.");
            }
        }

        // Quiz Logic Functions
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function showQuestion() {
            quizContent.innerHTML = '';
            const q = quizData[currentQuestionIndex];
            quizProgress.textContent = `${currentQuestionIndex + 1} / ${quizData.length}`;

            const questionEl = document.createElement('div');
            questionEl.innerHTML = `<h3 class="text-xl mb-6 text-gray-800">${q.question}</h3>`;

            const optionsContainer = document.createElement('div');
            optionsContainer.className = 'space-y-3';
            q.options.forEach((option, index) => {
                const optionEl = document.createElement('div');
                optionEl.className = 'answer-option p-4 rounded-lg';
                optionEl.dataset.index = index;
                optionEl.innerHTML = `<span class="option-text">${option.option_text}</span>
                                      <div class="explanation hidden mt-3 pt-3 border-t border-gray-200"></div>`;
                optionsContainer.appendChild(optionEl);
            });
            questionEl.appendChild(optionsContainer);
            quizContent.appendChild(questionEl);

            updateNavButtons();

            if (userAnswers[currentQuestionIndex] !== null) {
                redisplayAnsweredState();
            }
        }

        function handleAnswerSelection(selectedElement) {
            const selectedIndex = parseInt(selectedElement.dataset.index, 10);
            userAnswers[currentQuestionIndex] = selectedIndex;
            
            const options = quizContent.querySelectorAll('.answer-option');
            options.forEach((opt, index) => {
                const optionData = quizData[currentQuestionIndex].options[index];
                opt.classList.add('disabled');
                
                const explanationDiv = opt.querySelector('.explanation');
                
                if (optionData.is_correct) {
                    opt.classList.add('correct');
                } else if (index === selectedIndex) {
                    opt.classList.add('incorrect');
                }
                
                if (index === selectedIndex || optionData.is_correct) {
                    explanationDiv.innerHTML = marked.parse(optionData.explanation);
                    explanationDiv.classList.remove('hidden');
                }
            });
            updateNavButtons();
        }
        
        function redisplayAnsweredState() {
            const selectedIndex = userAnswers[currentQuestionIndex];
            if (selectedIndex === null) return;

            const options = quizContent.querySelectorAll('.answer-option');
            const selectedEl = options[selectedIndex];
            
            if (selectedEl) {
                handleAnswerSelection(selectedEl);
            }
        }

        function updateNavButtons() {
            previousQuestionBtn.disabled = currentQuestionIndex === 0;
            if (currentQuestionIndex === quizData.length - 1) {
                nextQuestionBtn.textContent = 'Finish';
            } else {
                nextQuestionBtn.textContent = 'Next';
            }
        }

        function showFinalResults() {
            quizSection.classList.add('hidden');
            resultsSection.classList.remove('hidden');
            
            let score = 0;
            const incorrectQuestions = [];
            userAnswers.forEach((answerIndex, questionIndex) => {
                if (answerIndex !== null) {
                    const question = quizData[questionIndex];
                    const selectedOption = question.options[answerIndex];
                    if (selectedOption.is_correct) {
                        score++;
                    } else {
                        incorrectQuestions.push({
                            questionData: question,
                            userAnswerIndex: answerIndex
                        });
                    }
                }
            });

            scoreDisplay.textContent = `You scored ${score} out of ${quizData.length}!`;
            reviewContent.innerHTML = '';

            if (incorrectQuestions.length > 0) {
                reviewSection.classList.remove('hidden');
                incorrectQuestions.forEach(item => {
                    const q = item.questionData;
                    const userAnswer = q.options[item.userAnswerIndex].option_text;
                    const correctAnswer = q.options.find(opt => opt.is_correct).option_text;
                    const explanation = q.options.find(opt => opt.is_correct).explanation;

                    const reviewEl = document.createElement('div');
                    reviewEl.className = 'bg-white p-4 rounded-lg shadow';
                    reviewEl.innerHTML = `
                        <p class="text-gray-800 mb-2">${q.question}</p>
                        <p class="text-sm"><span class="text-red-600">Your Answer:</span> ${userAnswer}</p>
                        <p class="text-sm"><span class="text-green-600">Correct Answer:</span> ${correctAnswer}</p>
                        <p class="text-sm mt-1 italic text-gray-600">${explanation}</p>
                    `;
                    reviewContent.appendChild(reviewEl);
                });
            }
        }
        
        // UI Utility Functions
        function resetUIForStartOver() {
            configSection.classList.remove('hidden');
            quizSection.classList.add('hidden');
            resultsSection.classList.add('hidden');
            uploadedFilesList.innerHTML = '';
            uploadedFiles = [];
            firstQuizData = [];
            generateQuizBtn.disabled = true;
            reviewSection.classList.add('hidden');
            reviewContent.innerHTML = '';
            hideError();
        }

        function handleError(error) {
            loaderSection.classList.add('hidden');
            let userMessage = 'Failed to generate quiz. Please try again.';
            if (error.message.includes('401')) {
                userMessage = 'There was an authentication issue with the AI service. Please try again shortly.';
            } else if (error.message.includes('unexpected response') || error.message.includes('Could not parse')) {
                userMessage = 'The AI returned an invalid response. Please try adjusting your prompt or files.';
            }
            showError(userMessage);
            console.error('Error:', error);
            resultsSection.classList.add('hidden'); 
            configSection.classList.remove('hidden');
        }

        function showError(message) {
            errorText.textContent = message;
            errorMessage.classList.remove('hidden');
        }

        function hideError() {
            errorMessage.classList.add('hidden');
        }
    </script>
</body>
</html>
